"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@tsed/core");
const constants_1 = require("../constants");
/**
 *
 * @param target
 * @param {MongooseSchemaOptions} options
 */
function schemaOptions(target, options) {
    const store = core_1.Store.from(target);
    if (!store.has(constants_1.MONGOOSE_SCHEMA_OPTIONS)) {
        store.set(constants_1.MONGOOSE_SCHEMA_OPTIONS, {});
    }
    if (options) {
        store.set(constants_1.MONGOOSE_SCHEMA_OPTIONS, core_1.deepExtends(store.get(constants_1.MONGOOSE_SCHEMA_OPTIONS), options));
    }
    return store.get(constants_1.MONGOOSE_SCHEMA_OPTIONS);
}
exports.schemaOptions = schemaOptions;
/**
 *
 * @param {Function} fn
 * @returns {any}
 */
function buildPreHook(fn) {
    return fn.length === 2
        ? function (next) {
            return fn(this, next);
        }
        : function (next, done) {
            return fn(this, next, done);
        };
}
exports.buildPreHook = buildPreHook;
/**
 *
 * @param target
 * @param {MongooseSchemaOptions} options
 */
function applySchemaOptions(target, options) {
    const store = core_1.Store.from(target);
    options = schemaOptions(target, options);
    if (store.has(constants_1.MONGOOSE_SCHEMA)) {
        const schema = store.get(constants_1.MONGOOSE_SCHEMA);
        if (options.plugins) {
            options.plugins.forEach(item => schema.plugin(item.plugin, item.options));
        }
        if (options.indexes) {
            options.indexes.forEach(item => schema.index(item.fields, item.options));
        }
        if (options.pre) {
            options.pre.forEach(item => schema.pre(item.method, !!item.parallel, buildPreHook(item.fn), item.errorCb));
        }
        if (options.post) {
            options.post.forEach(item => schema.post(item.method, item.fn));
        }
    }
}
exports.applySchemaOptions = applySchemaOptions;

//# sourceMappingURL=schemaOptions.js.map
