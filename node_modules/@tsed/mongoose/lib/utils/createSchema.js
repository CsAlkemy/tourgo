"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("@tsed/common");
const core_1 = require("@tsed/core");
const mongoose = require("mongoose");
const constants_1 = require("../constants");
const cleanProps_1 = require("./cleanProps");
const schemaOptions_1 = require("./schemaOptions");
const MONGOOSE_RESERVED_KEYS = ["_id"];
function setUpTarget(target) {
    target.prototype.serialize = function (options, converter) {
        const { checkRequiredValue, ignoreCallback } = options;
        return converter.serializeClass(this, {
            type: core_1.getClass(target),
            checkRequiredValue,
            ignoreCallback
        });
    };
}
function setUpSchema({ schema, virtuals }, options) {
    const mongooseSchema = new mongoose.Schema(schema, options);
    for (const [key, options] of virtuals.entries()) {
        mongooseSchema.virtual(key, options);
    }
    return mongooseSchema;
}
function isVirtualRef(options) {
    return options.ref && options.localField && options.foreignField;
}
function createSchema(target, options = {}) {
    const schema = setUpSchema(buildMongooseSchema(target), options.schemaOptions);
    schemaOptions_1.applySchemaOptions(target, options);
    setUpTarget(target);
    schema.loadClass(target);
    return schema;
}
exports.createSchema = createSchema;
function getSchema(target, options = {}) {
    const store = core_1.Store.from(target);
    if (!store.has(constants_1.MONGOOSE_SCHEMA)) {
        store.set(constants_1.MONGOOSE_SCHEMA, createSchema(target, options));
    }
    return store.get(constants_1.MONGOOSE_SCHEMA);
}
exports.getSchema = getSchema;
/**
 *
 * @param target
 * @returns {MongooseSchema}
 */
function buildMongooseSchema(target) {
    const properties = common_1.PropertyRegistry.getProperties(target);
    const schema = { schema: {}, virtuals: new Map() };
    if (properties) {
        const properties = common_1.PropertyRegistry.getProperties(target);
        properties.forEach((propertyMetadata, key) => {
            if (MONGOOSE_RESERVED_KEYS.includes(key)) {
                return;
            }
            // Keeping the Mongoose Schema separate so it can overwrite everything once schema has been built.
            const schemaTypeOptions = propertyMetadata.store.get(constants_1.MONGOOSE_SCHEMA) || {};
            if (isVirtualRef(schemaTypeOptions)) {
                schemaTypeOptions.justOne = !propertyMetadata.isArray;
                schema.virtuals.set(key, schemaTypeOptions);
                return;
            }
            schema.schema[key] = createSchemaTypeOptions(propertyMetadata);
        });
    }
    return schema;
}
exports.buildMongooseSchema = buildMongooseSchema;
function createSchemaTypeOptions(propertyMetadata) {
    const key = propertyMetadata.propertyKey;
    const rawMongooseSchema = propertyMetadata.store.get(constants_1.MONGOOSE_SCHEMA) || {};
    let schemaTypeOptions = {
        required: propertyMetadata.required
            ? function () {
                return propertyMetadata.isRequired(this[key]);
            }
            : false
    };
    if (!propertyMetadata.isClass) {
        const jsonSchema = propertyMetadata.store.get("schema") || {};
        const { minimum: min, maximum: max, minLength: minlength, maxLength: maxlength } = jsonSchema;
        let match = jsonSchema.pattern;
        if (match) {
            match = new RegExp(match);
        }
        schemaTypeOptions = Object.assign({}, schemaTypeOptions, { type: propertyMetadata.type, match,
            min,
            max,
            minlength,
            maxlength, enum: jsonSchema["enum"], default: jsonSchema["default"] });
    }
    else if (!rawMongooseSchema.ref) {
        // References are handled by the final merge
        schemaTypeOptions = Object.assign({}, schemaTypeOptions, { type: getSchema(propertyMetadata.type) });
    }
    schemaTypeOptions = cleanProps_1.cleanProps(Object.assign({}, schemaTypeOptions, rawMongooseSchema));
    if (propertyMetadata.isCollection) {
        if (propertyMetadata.isArray) {
            schemaTypeOptions = [schemaTypeOptions];
        }
        else {
            // Can be a Map or a Set;
            // Mongoose implements only Map;
            if (propertyMetadata.collectionType !== Map) {
                throw new Error(`Invalid collection type. ${propertyMetadata.collectionName} is not supported.`);
            }
            schemaTypeOptions = { type: Map, of: schemaTypeOptions };
        }
    }
    return schemaTypeOptions;
}
exports.createSchemaTypeOptions = createSchemaTypeOptions;

//# sourceMappingURL=createSchema.js.map
