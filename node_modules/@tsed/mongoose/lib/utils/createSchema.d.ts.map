{"version":3,"sources":["utils/createSchema.ts"],"names":[],"mappings":"AAAA,OAAO,EAAkD,gBAAgB,EAAmB,MAAM,cAAc,CAAC;AACjH,OAAO,EAAkB,IAAI,EAAC,MAAM,YAAY,CAAC;AACjD,OAAO,KAAK,QAAQ,MAAM,UAAU,CAAC;AACrC,OAAO,EAAC,cAAc,EAAC,MAAM,UAAU,CAAC;AAExC,OAAO,EAAC,cAAc,EAAE,qBAAqB,EAAC,MAAM,eAAe,CAAC;AAgCpE,wBAAgB,YAAY,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,OAAO,GAAE,qBAA0B,GAAG,QAAQ,CAAC,MAAM,CAQpG;AAED,wBAAgB,SAAS,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,OAAO,GAAE,qBAA0B,GAAG,QAAQ,CAAC,MAAM,CAQjG;AAED;;;;GAIG;AACH,wBAAgB,mBAAmB,CAAC,MAAM,EAAE,GAAG,GAAG,cAAc,CA2B/D;AAED,wBAAgB,uBAAuB,CAAC,gBAAgB,EAAE,gBAAgB,GAAG,cAAc,CAAC,GAAG,CAAC,CAsD/F","file":"createSchema.d.ts","sourcesContent":["import {ConverterService, IConverterOptions, JsonSchema, PropertyMetadata, PropertyRegistry} from \"@tsed/common\";\nimport {getClass, Store, Type} from \"@tsed/core\";\nimport * as mongoose from \"mongoose\";\nimport {SchemaTypeOpts} from \"mongoose\";\nimport {MONGOOSE_SCHEMA} from \"../constants\";\nimport {MongooseSchema, MongooseSchemaOptions} from \"../interfaces\";\nimport {cleanProps} from \"./cleanProps\";\nimport {applySchemaOptions} from \"./schemaOptions\";\n\nconst MONGOOSE_RESERVED_KEYS = [\"_id\"];\n\nfunction setUpTarget(target: Type<any>) {\n  target.prototype.serialize = function(options: IConverterOptions, converter: ConverterService) {\n    const {checkRequiredValue, ignoreCallback} = options;\n\n    return converter.serializeClass(this, {\n      type: getClass(target),\n      checkRequiredValue,\n      ignoreCallback\n    });\n  };\n}\n\nfunction setUpSchema({schema, virtuals}: MongooseSchema, options?: mongoose.SchemaOptions) {\n  const mongooseSchema = new mongoose.Schema(schema, options);\n\n  for (const [key, options] of virtuals.entries()) {\n    mongooseSchema.virtual(key, options);\n  }\n\n  return mongooseSchema;\n}\n\nfunction isVirtualRef(options: SchemaTypeOpts<any>) {\n  return options.ref && options.localField && options.foreignField;\n}\n\nexport function createSchema(target: Type<any>, options: MongooseSchemaOptions = {}): mongoose.Schema {\n  const schema = setUpSchema(buildMongooseSchema(target), options.schemaOptions);\n\n  applySchemaOptions(target, options);\n  setUpTarget(target);\n  schema.loadClass(target);\n\n  return schema;\n}\n\nexport function getSchema(target: Type<any>, options: MongooseSchemaOptions = {}): mongoose.Schema {\n  const store = Store.from(target);\n\n  if (!store.has(MONGOOSE_SCHEMA)) {\n    store.set(MONGOOSE_SCHEMA, createSchema(target, options));\n  }\n\n  return store.get(MONGOOSE_SCHEMA);\n}\n\n/**\n *\n * @param target\n * @returns {MongooseSchema}\n */\nexport function buildMongooseSchema(target: any): MongooseSchema {\n  const properties = PropertyRegistry.getProperties(target);\n  const schema: MongooseSchema = {schema: {}, virtuals: new Map()};\n\n  if (properties) {\n    const properties = PropertyRegistry.getProperties(target);\n\n    properties.forEach((propertyMetadata, key) => {\n      if (MONGOOSE_RESERVED_KEYS.includes(key as string)) {\n        return;\n      }\n\n      // Keeping the Mongoose Schema separate so it can overwrite everything once schema has been built.\n      const schemaTypeOptions = propertyMetadata.store.get(MONGOOSE_SCHEMA) || {};\n\n      if (isVirtualRef(schemaTypeOptions)) {\n        schemaTypeOptions.justOne = !propertyMetadata.isArray;\n        schema.virtuals.set(key as string, schemaTypeOptions);\n\n        return;\n      }\n\n      schema.schema[key as string] = createSchemaTypeOptions(propertyMetadata);\n    });\n  }\n\n  return schema;\n}\n\nexport function createSchemaTypeOptions(propertyMetadata: PropertyMetadata): SchemaTypeOpts<any> {\n  const key = propertyMetadata.propertyKey;\n  const rawMongooseSchema = propertyMetadata.store.get(MONGOOSE_SCHEMA) || {};\n\n  let schemaTypeOptions: SchemaTypeOpts<any> = {\n    required: propertyMetadata.required\n      ? function() {\n          return propertyMetadata.isRequired(this[key]);\n        }\n      : false\n  };\n\n  if (!propertyMetadata.isClass) {\n    const jsonSchema: JsonSchema = propertyMetadata.store.get(\"schema\") || {};\n    const {minimum: min, maximum: max, minLength: minlength, maxLength: maxlength} = jsonSchema;\n\n    let match: string | RegExp = jsonSchema.pattern;\n    if (match) {\n      match = new RegExp(match);\n    }\n\n    schemaTypeOptions = {\n      ...schemaTypeOptions,\n      type: propertyMetadata.type,\n      match,\n      min,\n      max,\n      minlength,\n      maxlength,\n      enum: jsonSchema[\"enum\"],\n      default: jsonSchema[\"default\"]\n    };\n  } else if (!rawMongooseSchema.ref) {\n    // References are handled by the final merge\n    schemaTypeOptions = {...schemaTypeOptions, type: getSchema(propertyMetadata.type)};\n  }\n\n  schemaTypeOptions = cleanProps({...schemaTypeOptions, ...rawMongooseSchema});\n\n  if (propertyMetadata.isCollection) {\n    if (propertyMetadata.isArray) {\n      schemaTypeOptions = [schemaTypeOptions];\n    } else {\n      // Can be a Map or a Set;\n      // Mongoose implements only Map;\n      if (propertyMetadata.collectionType !== Map) {\n        throw new Error(`Invalid collection type. ${propertyMetadata.collectionName} is not supported.`);\n      }\n\n      schemaTypeOptions = {type: Map, of: schemaTypeOptions};\n    }\n  }\n\n  return schemaTypeOptions;\n}\n"],"sourceRoot":"../../src"}