{"version":3,"sources":["utils/createSchema.ts"],"names":[],"mappings":";;AAAA,yCAAiH;AACjH,qCAAiD;AACjD,qCAAqC;AAErC,4CAA6C;AAE7C,6CAAwC;AACxC,mDAAmD;AAEnD,MAAM,sBAAsB,GAAG,CAAC,KAAK,CAAC,CAAC;AAEvC,SAAS,WAAW,CAAC,MAAiB;IACpC,MAAM,CAAC,SAAS,CAAC,SAAS,GAAG,UAAS,OAA0B,EAAE,SAA2B;QAC3F,MAAM,EAAC,kBAAkB,EAAE,cAAc,EAAC,GAAG,OAAO,CAAC;QAErD,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,EAAE;YACpC,IAAI,EAAE,eAAQ,CAAC,MAAM,CAAC;YACtB,kBAAkB;YAClB,cAAc;SACf,CAAC,CAAC;IACL,CAAC,CAAC;AACJ,CAAC;AAED,SAAS,WAAW,CAAC,EAAC,MAAM,EAAE,QAAQ,EAAiB,EAAE,OAAgC;IACvF,MAAM,cAAc,GAAG,IAAI,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;IAE5D,KAAK,MAAM,CAAC,GAAG,EAAE,OAAO,CAAC,IAAI,QAAQ,CAAC,OAAO,EAAE,EAAE;QAC/C,cAAc,CAAC,OAAO,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;KACtC;IAED,OAAO,cAAc,CAAC;AACxB,CAAC;AAED,SAAS,YAAY,CAAC,OAA4B;IAChD,OAAO,OAAO,CAAC,GAAG,IAAI,OAAO,CAAC,UAAU,IAAI,OAAO,CAAC,YAAY,CAAC;AACnE,CAAC;AAED,SAAgB,YAAY,CAAC,MAAiB,EAAE,UAAiC,EAAE;IACjF,MAAM,MAAM,GAAG,WAAW,CAAC,mBAAmB,CAAC,MAAM,CAAC,EAAE,OAAO,CAAC,aAAa,CAAC,CAAC;IAE/E,kCAAkB,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;IACpC,WAAW,CAAC,MAAM,CAAC,CAAC;IACpB,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;IAEzB,OAAO,MAAM,CAAC;AAChB,CAAC;AARD,oCAQC;AAED,SAAgB,SAAS,CAAC,MAAiB,EAAE,UAAiC,EAAE;IAC9E,MAAM,KAAK,GAAG,YAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAEjC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,2BAAe,CAAC,EAAE;QAC/B,KAAK,CAAC,GAAG,CAAC,2BAAe,EAAE,YAAY,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC;KAC3D;IAED,OAAO,KAAK,CAAC,GAAG,CAAC,2BAAe,CAAC,CAAC;AACpC,CAAC;AARD,8BAQC;AAED;;;;GAIG;AACH,SAAgB,mBAAmB,CAAC,MAAW;IAC7C,MAAM,UAAU,GAAG,yBAAgB,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;IAC1D,MAAM,MAAM,GAAmB,EAAC,MAAM,EAAE,EAAE,EAAE,QAAQ,EAAE,IAAI,GAAG,EAAE,EAAC,CAAC;IAEjE,IAAI,UAAU,EAAE;QACd,MAAM,UAAU,GAAG,yBAAgB,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;QAE1D,UAAU,CAAC,OAAO,CAAC,CAAC,gBAAgB,EAAE,GAAG,EAAE,EAAE;YAC3C,IAAI,sBAAsB,CAAC,QAAQ,CAAC,GAAa,CAAC,EAAE;gBAClD,OAAO;aACR;YAED,kGAAkG;YAClG,MAAM,iBAAiB,GAAG,gBAAgB,CAAC,KAAK,CAAC,GAAG,CAAC,2BAAe,CAAC,IAAI,EAAE,CAAC;YAE5E,IAAI,YAAY,CAAC,iBAAiB,CAAC,EAAE;gBACnC,iBAAiB,CAAC,OAAO,GAAG,CAAC,gBAAgB,CAAC,OAAO,CAAC;gBACtD,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAa,EAAE,iBAAiB,CAAC,CAAC;gBAEtD,OAAO;aACR;YAED,MAAM,CAAC,MAAM,CAAC,GAAa,CAAC,GAAG,uBAAuB,CAAC,gBAAgB,CAAC,CAAC;QAC3E,CAAC,CAAC,CAAC;KACJ;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;AA3BD,kDA2BC;AAED,SAAgB,uBAAuB,CAAC,gBAAkC;IACxE,MAAM,GAAG,GAAG,gBAAgB,CAAC,WAAW,CAAC;IACzC,MAAM,iBAAiB,GAAG,gBAAgB,CAAC,KAAK,CAAC,GAAG,CAAC,2BAAe,CAAC,IAAI,EAAE,CAAC;IAE5E,IAAI,iBAAiB,GAAwB;QAC3C,QAAQ,EAAE,gBAAgB,CAAC,QAAQ;YACjC,CAAC,CAAC;gBACE,OAAO,gBAAgB,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;YAChD,CAAC;YACH,CAAC,CAAC,KAAK;KACV,CAAC;IAEF,IAAI,CAAC,gBAAgB,CAAC,OAAO,EAAE;QAC7B,MAAM,UAAU,GAAe,gBAAgB,CAAC,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC;QAC1E,MAAM,EAAC,OAAO,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAC,GAAG,UAAU,CAAC;QAE5F,IAAI,KAAK,GAAoB,UAAU,CAAC,OAAO,CAAC;QAChD,IAAI,KAAK,EAAE;YACT,KAAK,GAAG,IAAI,MAAM,CAAC,KAAK,CAAC,CAAC;SAC3B;QAED,iBAAiB,qBACZ,iBAAiB,IACpB,IAAI,EAAE,gBAAgB,CAAC,IAAI,EAC3B,KAAK;YACL,GAAG;YACH,GAAG;YACH,SAAS;YACT,SAAS,EACT,IAAI,EAAE,UAAU,CAAC,MAAM,CAAC,EACxB,OAAO,EAAE,UAAU,CAAC,SAAS,CAAC,GAC/B,CAAC;KACH;SAAM,IAAI,CAAC,iBAAiB,CAAC,GAAG,EAAE;QACjC,4CAA4C;QAC5C,iBAAiB,qBAAO,iBAAiB,IAAE,IAAI,EAAE,SAAS,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAC,CAAC;KACpF;IAED,iBAAiB,GAAG,uBAAU,mBAAK,iBAAiB,EAAK,iBAAiB,EAAE,CAAC;IAE7E,IAAI,gBAAgB,CAAC,YAAY,EAAE;QACjC,IAAI,gBAAgB,CAAC,OAAO,EAAE;YAC5B,iBAAiB,GAAG,CAAC,iBAAiB,CAAC,CAAC;SACzC;aAAM;YACL,yBAAyB;YACzB,gCAAgC;YAChC,IAAI,gBAAgB,CAAC,cAAc,KAAK,GAAG,EAAE;gBAC3C,MAAM,IAAI,KAAK,CAAC,4BAA4B,gBAAgB,CAAC,cAAc,oBAAoB,CAAC,CAAC;aAClG;YAED,iBAAiB,GAAG,EAAC,IAAI,EAAE,GAAG,EAAE,EAAE,EAAE,iBAAiB,EAAC,CAAC;SACxD;KACF;IAED,OAAO,iBAAiB,CAAC;AAC3B,CAAC;AAtDD,0DAsDC","file":"createSchema.js","sourcesContent":["import {ConverterService, IConverterOptions, JsonSchema, PropertyMetadata, PropertyRegistry} from \"@tsed/common\";\nimport {getClass, Store, Type} from \"@tsed/core\";\nimport * as mongoose from \"mongoose\";\nimport {SchemaTypeOpts} from \"mongoose\";\nimport {MONGOOSE_SCHEMA} from \"../constants\";\nimport {MongooseSchema, MongooseSchemaOptions} from \"../interfaces\";\nimport {cleanProps} from \"./cleanProps\";\nimport {applySchemaOptions} from \"./schemaOptions\";\n\nconst MONGOOSE_RESERVED_KEYS = [\"_id\"];\n\nfunction setUpTarget(target: Type<any>) {\n  target.prototype.serialize = function(options: IConverterOptions, converter: ConverterService) {\n    const {checkRequiredValue, ignoreCallback} = options;\n\n    return converter.serializeClass(this, {\n      type: getClass(target),\n      checkRequiredValue,\n      ignoreCallback\n    });\n  };\n}\n\nfunction setUpSchema({schema, virtuals}: MongooseSchema, options?: mongoose.SchemaOptions) {\n  const mongooseSchema = new mongoose.Schema(schema, options);\n\n  for (const [key, options] of virtuals.entries()) {\n    mongooseSchema.virtual(key, options);\n  }\n\n  return mongooseSchema;\n}\n\nfunction isVirtualRef(options: SchemaTypeOpts<any>) {\n  return options.ref && options.localField && options.foreignField;\n}\n\nexport function createSchema(target: Type<any>, options: MongooseSchemaOptions = {}): mongoose.Schema {\n  const schema = setUpSchema(buildMongooseSchema(target), options.schemaOptions);\n\n  applySchemaOptions(target, options);\n  setUpTarget(target);\n  schema.loadClass(target);\n\n  return schema;\n}\n\nexport function getSchema(target: Type<any>, options: MongooseSchemaOptions = {}): mongoose.Schema {\n  const store = Store.from(target);\n\n  if (!store.has(MONGOOSE_SCHEMA)) {\n    store.set(MONGOOSE_SCHEMA, createSchema(target, options));\n  }\n\n  return store.get(MONGOOSE_SCHEMA);\n}\n\n/**\n *\n * @param target\n * @returns {MongooseSchema}\n */\nexport function buildMongooseSchema(target: any): MongooseSchema {\n  const properties = PropertyRegistry.getProperties(target);\n  const schema: MongooseSchema = {schema: {}, virtuals: new Map()};\n\n  if (properties) {\n    const properties = PropertyRegistry.getProperties(target);\n\n    properties.forEach((propertyMetadata, key) => {\n      if (MONGOOSE_RESERVED_KEYS.includes(key as string)) {\n        return;\n      }\n\n      // Keeping the Mongoose Schema separate so it can overwrite everything once schema has been built.\n      const schemaTypeOptions = propertyMetadata.store.get(MONGOOSE_SCHEMA) || {};\n\n      if (isVirtualRef(schemaTypeOptions)) {\n        schemaTypeOptions.justOne = !propertyMetadata.isArray;\n        schema.virtuals.set(key as string, schemaTypeOptions);\n\n        return;\n      }\n\n      schema.schema[key as string] = createSchemaTypeOptions(propertyMetadata);\n    });\n  }\n\n  return schema;\n}\n\nexport function createSchemaTypeOptions(propertyMetadata: PropertyMetadata): SchemaTypeOpts<any> {\n  const key = propertyMetadata.propertyKey;\n  const rawMongooseSchema = propertyMetadata.store.get(MONGOOSE_SCHEMA) || {};\n\n  let schemaTypeOptions: SchemaTypeOpts<any> = {\n    required: propertyMetadata.required\n      ? function() {\n          return propertyMetadata.isRequired(this[key]);\n        }\n      : false\n  };\n\n  if (!propertyMetadata.isClass) {\n    const jsonSchema: JsonSchema = propertyMetadata.store.get(\"schema\") || {};\n    const {minimum: min, maximum: max, minLength: minlength, maxLength: maxlength} = jsonSchema;\n\n    let match: string | RegExp = jsonSchema.pattern;\n    if (match) {\n      match = new RegExp(match);\n    }\n\n    schemaTypeOptions = {\n      ...schemaTypeOptions,\n      type: propertyMetadata.type,\n      match,\n      min,\n      max,\n      minlength,\n      maxlength,\n      enum: jsonSchema[\"enum\"],\n      default: jsonSchema[\"default\"]\n    };\n  } else if (!rawMongooseSchema.ref) {\n    // References are handled by the final merge\n    schemaTypeOptions = {...schemaTypeOptions, type: getSchema(propertyMetadata.type)};\n  }\n\n  schemaTypeOptions = cleanProps({...schemaTypeOptions, ...rawMongooseSchema});\n\n  if (propertyMetadata.isCollection) {\n    if (propertyMetadata.isArray) {\n      schemaTypeOptions = [schemaTypeOptions];\n    } else {\n      // Can be a Map or a Set;\n      // Mongoose implements only Map;\n      if (propertyMetadata.collectionType !== Map) {\n        throw new Error(`Invalid collection type. ${propertyMetadata.collectionName} is not supported.`);\n      }\n\n      schemaTypeOptions = {type: Map, of: schemaTypeOptions};\n    }\n  }\n\n  return schemaTypeOptions;\n}\n"],"sourceRoot":"../../src"}