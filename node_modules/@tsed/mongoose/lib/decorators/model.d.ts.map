{"version":3,"sources":["decorators/model.ts"],"names":[],"mappings":"AAAA,OAAO,EAAC,oBAAoB,EAAC,MAAM,oCAAoC,CAAC;AAKxE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAoCG;AACH,wBAAgB,KAAK,CAAC,OAAO,GAAE,oBAAyB,yBAKvD","file":"model.d.ts","sourcesContent":["import {MongooseModelOptions} from \"../interfaces/MongooseModelOptions\";\nimport {registerModel} from \"../registries/MongooseModelRegistry\";\nimport {createModel, getSchema} from \"../utils\";\nimport {applySchemaOptions} from \"../utils/schemaOptions\";\n\n/**\n * Define a class as a Mongoose Model. The model can be injected to the Service, Controller, Middleware, Converters or Filter with\n * `@Inject` annotation.\n *\n * ### Example\n *\n * ```typescript\n * @Model()\n * export class EventModel {\n *   @Property()\n *   field: string;\n * }\n * ```\n *\n * Then inject the model into a service:\n *\n * ```typescript\n * class MyService {\n *    constructor(@Inject(EventModel) eventModel: MongooseModel<EventModel>) {\n *        eventModel.find().exec();\n *    }\n * }\n * ```\n *\n * ### Options\n *\n * - `schemaOptions` (mongoose.SchemaOptions): Option to configure the schema behavior.\n * - `name` (String): model name.\n * - `collection` (String): collection (optional, induced from model name).\n * - `skipInit` (Boolean): skipInit whether to skip initialization (defaults to false).\n *\n * @param {MongooseModelOptions} options\n * @returns {(target: any) => void}\n * @decorator\n * @mongoose\n * @class\n */\nexport function Model(options: MongooseModelOptions = {}) {\n  return (target: any) => {\n    registerModel(target, createModel(target, getSchema(target, options), options.name, options.collection, options.skipInit));\n    applySchemaOptions(target, {});\n  };\n}\n"],"sourceRoot":"../../src"}