{"version":3,"sources":["decorators/model.ts"],"names":[],"mappings":";;AACA,+EAAkE;AAClE,oCAAgD;AAChD,0DAA0D;AAE1D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAoCG;AACH,SAAgB,KAAK,CAAC,UAAgC,EAAE;IACtD,OAAO,CAAC,MAAW,EAAE,EAAE;QACrB,qCAAa,CAAC,MAAM,EAAE,mBAAW,CAAC,MAAM,EAAE,iBAAS,CAAC,MAAM,EAAE,OAAO,CAAC,EAAE,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,UAAU,EAAE,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC;QAC3H,kCAAkB,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;IACjC,CAAC,CAAC;AACJ,CAAC;AALD,sBAKC","file":"model.js","sourcesContent":["import {MongooseModelOptions} from \"../interfaces/MongooseModelOptions\";\nimport {registerModel} from \"../registries/MongooseModelRegistry\";\nimport {createModel, getSchema} from \"../utils\";\nimport {applySchemaOptions} from \"../utils/schemaOptions\";\n\n/**\n * Define a class as a Mongoose Model. The model can be injected to the Service, Controller, Middleware, Converters or Filter with\n * `@Inject` annotation.\n *\n * ### Example\n *\n * ```typescript\n * @Model()\n * export class EventModel {\n *   @Property()\n *   field: string;\n * }\n * ```\n *\n * Then inject the model into a service:\n *\n * ```typescript\n * class MyService {\n *    constructor(@Inject(EventModel) eventModel: MongooseModel<EventModel>) {\n *        eventModel.find().exec();\n *    }\n * }\n * ```\n *\n * ### Options\n *\n * - `schemaOptions` (mongoose.SchemaOptions): Option to configure the schema behavior.\n * - `name` (String): model name.\n * - `collection` (String): collection (optional, induced from model name).\n * - `skipInit` (Boolean): skipInit whether to skip initialization (defaults to false).\n *\n * @param {MongooseModelOptions} options\n * @returns {(target: any) => void}\n * @decorator\n * @mongoose\n * @class\n */\nexport function Model(options: MongooseModelOptions = {}) {\n  return (target: any) => {\n    registerModel(target, createModel(target, getSchema(target, options), options.name, options.collection, options.skipInit));\n    applySchemaOptions(target, {});\n  };\n}\n"],"sourceRoot":"../../src"}