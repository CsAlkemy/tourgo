{"version":3,"sources":["decorators/virtualRef.ts"],"names":[],"mappings":";;AAAA,yCAAsC;AACtC,qCAA8D;AAC9D,4CAAkE;AAgDlE,SAAgB,UAAU,CAAC,OAA2C,EAAE,YAAqB;IAC3F,OAAO,CAAC,MAAW,EAAE,WAAmB,EAAE,UAAe,EAAE,EAAE;QAC3D,IAAI,MAAW,EAAE,IAAS,CAAC;QAC3B,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;YAC/B,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;YACpB,MAAM,GAAG;gBACP,GAAG,EAAE,OAAO,IAAI,KAAK,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,YAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,+BAAmB,CAAC;gBAChF,UAAU,EAAE,OAAO,CAAC,UAAU,IAAI,WAAW;gBAC7C,YAAY,EAAE,OAAO,CAAC,YAAY;gBAClC,OAAO,EAAE,OAAO,CAAC,OAAO,IAAI,KAAK;gBACjC,OAAO,EAAE,OAAO,CAAC,OAAO;aACzB,CAAC;SACH;aAAM;YACL,MAAM,GAAG;gBACP,GAAG,EAAE,OAAO;gBACZ,UAAU,EAAE,WAAW;gBACvB,YAAY;aACb,CAAC;SACH;QAED,OAAO,sBAAe,CAAC,iBAAQ,CAAC,EAAC,IAAI,EAAE,MAAM,CAAC,UAAU,EAAE,GAAG,EAAE,IAAI,EAAC,CAAC,EAAE,iBAAU,CAAC,2BAAe,EAAE,MAAM,CAAC,CAAC,CACzG,MAAM,EACN,WAAW,EACX,UAAU,CACX,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC;AA1BD,gCA0BC","file":"virtualRef.js","sourcesContent":["import {Property} from \"@tsed/common\";\nimport {applyDecorators, Store, StoreMerge} from \"@tsed/core\";\nimport {MONGOOSE_MODEL_NAME, MONGOOSE_SCHEMA} from \"../constants\";\nimport {MongooseVirtualRefOptions} from \"../interfaces/MongooseVirtualRefOptions\";\n\nexport type VirtualRef<T> = T | null;\nexport type VirtualRefs<T> = T[];\n\n/**\n * Define a property as mongoose virtual reference to other Model (decorated with @Model).\n *\n * ::: warning\n * To avoid circular dependencies, do not use the virtual reference model in\n * anything except a type declaration. Using the virtual reference model will prevent\n * typescript transpiler from stripping away the import statement and cause a circular\n * import in node.\n * :::\n *\n * ### Example\n *\n * ```typescript\n *\n * @Model()\n * class FooModel {\n *\n *    @VirtualRef(\"Foo2Model\", \"foo\")\n *    field: VirtualRef<Foo2Model>\n *\n *    @VirtualRef(\"Foo2Model\", \"foo\")\n *    list: VirtualRefs<Foo2Model>\n * }\n *\n * @Model()\n * class Foo2Model {\n *    @Ref(FooModel)\n *    foo: Ref<FooModel>;\n * }\n * ```\n *\n * @param type\n * @param foreignField\n * @returns {Function}\n * @decorator\n * @mongoose\n * @property\n */\nexport function VirtualRef(type: string, foreignField: string): Function;\nexport function VirtualRef(options: MongooseVirtualRefOptions): Function;\nexport function VirtualRef(options: string | MongooseVirtualRefOptions, foreignField?: string): Function;\n\nexport function VirtualRef(options: string | MongooseVirtualRefOptions, foreignField?: string): Function {\n  return (target: any, propertyKey: string, descriptor: any) => {\n    let schema: any, type: any;\n    if (typeof options === \"object\") {\n      type = options.type;\n      schema = {\n        ref: typeof type === \"string\" ? type : Store.from(type).get(MONGOOSE_MODEL_NAME),\n        localField: options.localField || propertyKey,\n        foreignField: options.foreignField,\n        justOne: options.justOne || false,\n        options: options.options\n      };\n    } else {\n      schema = {\n        ref: options,\n        localField: propertyKey,\n        foreignField\n      };\n    }\n\n    return applyDecorators(Property({name: schema.localField, use: type}), StoreMerge(MONGOOSE_SCHEMA, schema))(\n      target,\n      propertyKey,\n      descriptor\n    );\n  };\n}\n"],"sourceRoot":"../../src"}