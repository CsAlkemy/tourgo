{"version":3,"sources":["decorators/virtualRef.ts"],"names":[],"mappings":"AAGA,OAAO,EAAC,yBAAyB,EAAC,MAAM,yCAAyC,CAAC;AAElF,oBAAY,UAAU,CAAC,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;AACrC,oBAAY,WAAW,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC;AAEjC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAqCG;AACH,wBAAgB,UAAU,CAAC,IAAI,EAAE,MAAM,EAAE,YAAY,EAAE,MAAM,GAAG,QAAQ,CAAC;AACzE,wBAAgB,UAAU,CAAC,OAAO,EAAE,yBAAyB,GAAG,QAAQ,CAAC;AACzE,wBAAgB,UAAU,CAAC,OAAO,EAAE,MAAM,GAAG,yBAAyB,EAAE,YAAY,CAAC,EAAE,MAAM,GAAG,QAAQ,CAAC","file":"virtualRef.d.ts","sourcesContent":["import {Property} from \"@tsed/common\";\nimport {applyDecorators, Store, StoreMerge} from \"@tsed/core\";\nimport {MONGOOSE_MODEL_NAME, MONGOOSE_SCHEMA} from \"../constants\";\nimport {MongooseVirtualRefOptions} from \"../interfaces/MongooseVirtualRefOptions\";\n\nexport type VirtualRef<T> = T | null;\nexport type VirtualRefs<T> = T[];\n\n/**\n * Define a property as mongoose virtual reference to other Model (decorated with @Model).\n *\n * ::: warning\n * To avoid circular dependencies, do not use the virtual reference model in\n * anything except a type declaration. Using the virtual reference model will prevent\n * typescript transpiler from stripping away the import statement and cause a circular\n * import in node.\n * :::\n *\n * ### Example\n *\n * ```typescript\n *\n * @Model()\n * class FooModel {\n *\n *    @VirtualRef(\"Foo2Model\", \"foo\")\n *    field: VirtualRef<Foo2Model>\n *\n *    @VirtualRef(\"Foo2Model\", \"foo\")\n *    list: VirtualRefs<Foo2Model>\n * }\n *\n * @Model()\n * class Foo2Model {\n *    @Ref(FooModel)\n *    foo: Ref<FooModel>;\n * }\n * ```\n *\n * @param type\n * @param foreignField\n * @returns {Function}\n * @decorator\n * @mongoose\n * @property\n */\nexport function VirtualRef(type: string, foreignField: string): Function;\nexport function VirtualRef(options: MongooseVirtualRefOptions): Function;\nexport function VirtualRef(options: string | MongooseVirtualRefOptions, foreignField?: string): Function;\n\nexport function VirtualRef(options: string | MongooseVirtualRefOptions, foreignField?: string): Function {\n  return (target: any, propertyKey: string, descriptor: any) => {\n    let schema: any, type: any;\n    if (typeof options === \"object\") {\n      type = options.type;\n      schema = {\n        ref: typeof type === \"string\" ? type : Store.from(type).get(MONGOOSE_MODEL_NAME),\n        localField: options.localField || propertyKey,\n        foreignField: options.foreignField,\n        justOne: options.justOne || false,\n        options: options.options\n      };\n    } else {\n      schema = {\n        ref: options,\n        localField: propertyKey,\n        foreignField\n      };\n    }\n\n    return applyDecorators(Property({name: schema.localField, use: type}), StoreMerge(MONGOOSE_SCHEMA, schema))(\n      target,\n      propertyKey,\n      descriptor\n    );\n  };\n}\n"],"sourceRoot":"../../src"}